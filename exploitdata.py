import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from tkinter import *
from tkinter import ttk
from tkinter import filedialog
from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
import time
import numpy as np

# Auteur: Paul Roc <paul.rocPR@gmail.com>
#
# Reste à faire:
#                - intégrer le graph dans une fenetre
#                -
#
#
error_msg = 'OK'
NAME_FILE = ''
liste_col = list(['choix 1','choix2'])


def init_data(NAME_FILE):
    global liste_col
    global error_msg
    global data
    # NAME_FILE = champ_nom_fichier.get
    NAME_DATA = ''
    NAME_EXT = ''
    i = int(0)
    # NAME_FILE = str(input('Saisir nom_fichier.extension:\n'))
    # print('NAME_FILE={}'.format(NAME_FILE))
    # creation du nom du fichier et de son extension
    while NAME_FILE[i] != '.':
        NAME_DATA += NAME_FILE[i]
        # print(NAME_DATA)
        i += 1
        imax = i
        if imax == len(NAME_FILE) - 1:
            error_msg = "PAS D'EXTENSION"
            print(error_msg)
            # exit(0)
    print('NAME_DATA={}'.format(NAME_DATA))
    for i in range(imax + 1, len(NAME_FILE)):
        NAME_EXT += NAME_FILE[i]
    print('NAME_EXT={}'.format(NAME_EXT))

    if NAME_EXT == 'xlsx':
        data = pd.read_excel(NAME_FILE)
        liste_col = list(data.columns)
        tab_data = data.values
        print('liste_col= {}'.format(liste_col))
    elif NAME_EXT == 'csv':
        data = pd.read_csv(NAME_FILE)
        liste_col = list(data.columns)
        tab_data = data.values
        print('liste_col= {}'.format(liste_col))
    else:
        error_msg = 'extension non prise en charge'
        print(error_msg)
        # exit(0)
    return error_msg, liste_col, tab_data

def plot(data):
    taille_fig=(10,7)
    # choix du model
    if var_model.get() == 1:  # cas model lineaire
        model = LinearRegression()
        # recup  intitulés des colonnes selectionnées
        columnX = liste_Xcolumn.get()
        columnY = liste_Ycolumn.get()
        # creation d'un dataframe composé uniquement
        # données selectionnées par l'utilisateur
        DATA_XY = data[[columnX, columnY]]
        # conversion des données en tableau
        tab_data = DATA_XY.values
        X = tab_data[:, 0].reshape(len(tab_data), 1)
        Y = tab_data[:, 1].reshape(len(tab_data), 1)
        model.fit(X, Y)
        R2 = model.score(X, Y)
        Y_pred = model.predict(X)
        fig1 = plt.figure(figsize=taille_fig)
        plt.subplot(111)
        plt.scatter(tab_data[:, 0], tab_data[:, 1],
                    c='black',
                    marker='+',
                    label=r'données exp')
        plt.plot(tab_data[:, 0], Y_pred,
                 c='red',
                 label=r'$R^2$={:.3f}'.format(R2),
                 linewidth=1)
        plt.title(f'{columnY} en fonction de {columnX} : ')
        plt.xlabel(str(columnX))
        plt.ylabel(str(columnY))
        plt.legend()
        plt.grid()
        plt.show()
    elif var_model.get() == 0:  # cas non lineaire
        model = SVR(C=100)
        # recup  intitulés des colonnes selectionnées
        columnX = liste_Xcolumn.get()
        columnY = liste_Ycolumn.get()
        # creation d'un dataframe composé uniquement
        # données selectionnées par l'utilisateur
        DATA_XY = data[[columnX, columnY]]
        # conversion des données en tableau
        tab_data = DATA_XY.values
        X = tab_data[:, 0].reshape(len(tab_data), 1)
        Y = tab_data[:, 1].reshape(len(tab_data), 1)
        model.fit(X, Y)
        R2 = model.score(X, Y)
        Y_pred = model.predict(X)
        fig1 = plt.figure(figsize=taille_fig)
        plt.subplot(111)
        plt.scatter(tab_data[:, 0], tab_data[:, 1],
                    c='black',
                    marker='+',
                    label=r'données exp')
        plt.plot(tab_data[:, 0], Y_pred,
                 c='red',
                 label=r'$R^2$={:.3f}'.format(R2),
                 linewidth=1)
        plt.title(f'{columnY} en fonction de {columnX} : ')
        plt.xlabel(str(columnX))
        plt.ylabel(str(columnY))
        plt.legend()
        plt.grid()
        plt.show()
    elif var_model.get() ==2:
        columnX = liste_Xcolumn.get()
        columnY = liste_Ycolumn.get()
        # creation d'un dataframe composé uniquement
        # données selectionnées par l'utilisateur
        DATA_XY = data[[columnX, columnY]]
        # conversion des données en tableau
        tab_data = DATA_XY.values

        fig1 = plt.figure(figsize=(15, 6.8))
        plt.subplot(111)
        plt.scatter(tab_data[:, 0], tab_data[:, 1],
                    c='black',
                    marker='+',
                    label=r'données exp')

        plt.title(f'{columnY} en fonction de {columnX} : ')
        plt.xlabel(str(columnX))
        plt.ylabel(str(columnY))
        plt.legend()
        plt.grid()
        plt.show()

    else: error_msg.set('Erreur model choice')
    Y_calcul = Label(root,
                     text=f'Calcul de ({columnY}) \n en fonction de ({columnX})',
                     bg=color_grey,
                     fg='black'
                     ).grid(row=12, column=0)
    X_value = IntVar()
    X_entry = Entry(root,
                    bg='white',
                    fg='black',
                    justify='right',
                    textvariable=X_value,
                    bd=0.5,
                    highlightthickness=0
                    ).grid(row=13, column=0)
    bt_calculY = Button(root,
                        text='Calcul',
                        bd=1,
                        highlightthickness=0,
                        command = lambda:\
                            action_bt_CALCUL(X_value.get(), Y_value, model, columnY)
                        ).grid(row=14, column=0)
    Y_value =IntVar()
    Y_output=Entry(root,
                   textvariable=Y_value,
                   bg='white',
                   fg='black',
                   justify='right',
                   bd=0,
                   width=20,
                   highlightthickness=0
                  ).grid(row=15, column=0)
def action_bt_CALCUL(X_entry, Y_output, model,columnY):
    Xscal = np.array(X_entry).reshape(1, 1)
    Y_pred_scal =model.predict(Xscal)
    Y_output.set(str(columnY)+'='+str(float(Y_pred_scal)))
color_grey = '#ECECEC'
root = Tk()
root.title('Visualisation de données')
root.geometry('1920x720')
root.minsize(1080, 720)
root.configure(bg=color_grey)

text_cp_name_file = StringVar()
root.filename = filedialog.askopenfilename(initialdir='~/Desktop',
                                          title='Select a file',
                                          filetypes=(('excel files','*.xlsx'),('csv files','*.csv'))
                                          )
NAME_DIR_FILE = str(root.filename)
saisir_nom_fichier = Label(root,
                           text="chemin du fichier de données:",
                           bg=color_grey,
                           fg='black'
                           ).grid(row=0, column=0)
champ_nom_fichier = Label(root,
                          bg=color_grey,
                          fg='black',
                          bd=0,
                          text=NAME_DIR_FILE,
                          highlightthickness=0,
                          width=40,
                          ).grid(row=0, column=1)

error_msg, liste_col, tab_data = init_data(str(root.filename))

'''bt_valider_champ_nom_fichier = Button(root,
                                      text='VALIDER',
                                      bd=1,
                                      bg=color_grey,
                                      highlightthickness=0,
                                      width=20,
                                      command=lambda: init_data(text_cp_name_file.get()),
                                      ).grid(row=3, column=0)'''

####
X_colonne = Label(root,
                  text='X values :',
                  bg=color_grey,
                  fg='black',
                  width =10
                  ).grid(row=3, column=0)

liste_Xcolumn = ttk.Combobox(root, values=liste_col)
liste_Ycolumn = ttk.Combobox(root, values=liste_col)
liste_Xcolumn.grid(row=4, column=0)
liste_Ycolumn.grid(row=6, column=0)

Y_colonne = Label(root,
                  text='Y values :',
                  bg=color_grey,
                  fg='black',
                  width =10
                  ).grid(row=5, column=0)


var_model = IntVar()

coche_model = Label(root,
                    text="Choix du model:",
                    bg=color_grey,
                    fg='black'
                    ).grid(row=7, column=0)

Radiobutton(root, text='Linear Regression',
            variable=var_model,
            value=1,
            bg=color_grey,
            fg='black'
            ).grid(row=8, column=0)
Radiobutton(root,
            text='Support vector machine',
            variable=var_model,
            value=0,
            bg=color_grey,
            fg='black'
            ).grid(row=9, column=0)
Radiobutton(root,
            text='Aucun',
            variable=var_model,
            value=2,
            bg=color_grey,
            fg='black'
            ).grid(row=10, column=0)


bt_lancer_calcul = Button(root,
                          text='RUN',
                          bd=0,
                          highlightthickness=0,
                          command=lambda: plot(data)
                          ).grid(row=11, column=0)

'''X_entry.set(root,
            text='Saisir X',
            fg = color_grey
            )
'''

error_msg_Label = Label(root,
                        text='error message',
                        bg=color_grey,
                        fg='black'
                        ).grid(row=16, column=0)

error_msg =StringVar()
error_msg_display = Label(root,
                          textvariable=error_msg,
                          bg='white',
                          fg='black',
                          width=20,
                          pady=30,
                          ).grid(row=17, column=0)

root.mainloop()
'''
x_name, y_name, data, tab_data = choice_columns(init_data())
print('ok')
X, Y_pred, R2 = model_ML(tab_data,choice_model())
disp_data(x_name, y_name, tab_data,Y_pred,R2)
'''

'''
def choice_columns(data):
    columns = data.columns
    i = int(0)
    print(data.columns)
    X_NAME = str(input('pour les x entrer le titre de la colonne\n'))
    while X_NAME != columns[i]:
        imax = i
        if imax == len(columns) - 1:
            error_msg = 'la colonne x entrée ne correspond a aucune colonnes du dataset'
            print(error_msg)
            exit(0)
        i += 1

    Y_NAME = str(input('pour les y entrer le titre de la colonne\n'))
    while Y_NAME != columns[i]:
        imax = i
        if imax == len(columns) - 1:
            error_msg = 'la colonne y entrée ne correspond a aucune colonnes du dataset'
            print(error_msg)
            exit(0)
        i += 1
    if X_NAME == Y_NAME:
        error_msg = 'X et Y ne peuvent etre egaux'
        print(error_msg)
        exit(0)
    data = data[[X_NAME, Y_NAME]]
    tab_data = data.values

    return X_NAME, Y_NAME, data, tab_data


def choice_model():
    global model
    print('Modele lineaire     -1')
    print('Modele non-lineaire -2')
    MODEL_TYPE = int(input('?: '))
    if MODEL_TYPE == 1:  # cas model lineaire
        model = LinearRegression()
    if MODEL_TYPE == 2:  # cas non lineaire
        model = SVR(C=100)
    return model


def model_ML(tab_data, model):
    X = tab_data[:, 0].reshape(len(tab_data), 1)
    Y = tab_data[:, 1].reshape(len(tab_data), 1)
    model.fit(X, Y)
    Y_pred = model.predict(X)
    R2 = model.score(X, Y)
    return X, Y_pred, R2


def disp_data(x_name, y_name, tab_data, Y_pred, R2):
    fig1 = plt.figure(figsize=(15, 6.8))
    plt.subplot(111)
    plt.scatter(tab_data[:, 0], tab_data[:, 1],
                c='black',
                marker='+',
                label=r'données exp')
    plt.plot(tab_data[:, 0], Y_pred,
             c='red',
             label=r'$R^2$={:.3f}'.format(R2),
             linewidth=1)
    plt.xlabel(x_name)
    plt.ylabel(y_name)
    plt.title(y_name + str(' en fonction de ') + x_name)
    plt.legend()
    plt.grid()
    plt.show()

'''